---
title: "DEA_neuroblastoma"
author: "Kate Petrenko"
date: "2025-01-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(data.table)
library(Seurat)
library(scDblFinder)
library(DoubletFinder)
library(dplyr)
library(remotes)
# remotes::install_github("carmonalab/STACAS")
library(STACAS)
library(SingleR)
# install.packages("scGate")
library(scGate)
library(ggplot2)
library(BiocParallel)
library(harmony)
library(RColorBrewer)
library(stringr)
library(cowplot)
library(scuttle)
# install.packages("devtools")
# BiocManager::install("Homo.sapiens")
# BiocManager::install("jpmam1/scalop") #forked copy of a really good guy 
# devtools::install_github("jlaffy/infercna")
library(infercna)
library(infercnv)
library(parallel)
library(future)
library(clustree)
library(dittoSeq)
# install.packages("ggh4x")
library(ggh4x)
#BiocManager::install('EnhancedVolcano')
library(EnhancedVolcano)
library(clusterProfiler)
library("org.Hs.eg.db")
library(ReactomePA)
library(msigdbr)
# install.packages('qs')
library(qs)
library(DESeq2)
library(magrittr)
library(tibble)
library(tidyr)
library(pheatmap)
# BiocManager::install('apeglm')
# install.packages('ashr')
library(edgeR)
library(reticulate)
# install.packages('anndata')
library(anndata)
# devtools::install_github("cellgeni/sceasy")
# BiocManager::install(c("LoomExperiment"))
library(sceasy)
library(SeuratData)
# BiocManager::install("MAST")
library(MAST)
# install.packages("metafor")
library(metafor)
```

```{r global variables, include=FALSE}
set.seed(100)
DATADIR = '~/neuroblastoma/data/'
WORKDIR = '~/neuroblastoma/'
PREPRDATADIR = '~/neuroblastoma/preprocessing_data/'

my_colors <- c("#9ACD32FF", "#4682B4FF",  "#DDA0DDFF", "#FFA07AFF", "#8FBC8BFF",
               "#40E0D0FF",  "#F0E68CFF", "#5F9EA0FF", "#D2B48CFF",  
               "#6495EDFF", "#FF69B4FF", "#BA55D3FF",  "#F08080FF", "#32CD32FF",  
               "#FFDAB9FF",  "#87CEEBFF")
```

```{r}
atlas <- qread(paste0(PREPRDATADIR, 'ATLAS_object.qs'))

sample_metadata <- read.csv(paste0(DATADIR, 'samples_metadata_v5.csv'))
sample_metadata[sample_metadata==""] <- NA

rownames(sample_metadata) <- sample_metadata$Sample_dataset



clean_sample_id <- function(id) {
  # First remove _rep1 and _rep2
  id <- gsub("_rep[12]$", "", id)
  
  # Handle the special bonine cases
  id <- gsub("_sn$", "", id)      # Remove _sn suffix
  id <- gsub("_[12]$", "", id)    # Remove _1 or _2 suffix
  
  return(id)
}

atlas$less18M <- sample_metadata[clean_sample_id(atlas$SampleID),]$less18M
atlas$Sex <- sample_metadata[clean_sample_id(atlas$SampleID),]$Sex
atlas$MYCN_status <- sample_metadata[clean_sample_id(atlas$SampleID),]$MYCN
atlas$method <- sample_metadata[clean_sample_id(atlas$SampleID),]$Method
```

# Pseudobulk

```{r create patlasdoreplicates, eval=FALSE, include=FALSE}
atlas$less18M <- as.character(atlas$less18M)
atlas$rep <- NA
create_pseudorep <- function(atlas) {
  
  rep1 <- c()
  rep2 <- c()
  rep3 <- c()
  reps <- list(rep1, rep2, rep3)
  
  samples <- atlas$SampleID %>% unique
  cell_types <- atlas$Annotation %>% unique
  sample_annot_table <- table(atlas$Annotation, atlas$SampleID)
  for (sample in samples) {
    for (celltype in cell_types) {
      
      if (sample_annot_table[celltype, sample] >= 150) {
        
        cells <- WhichCells(atlas, expression = Annotation ==  celltype & SampleID == sample)
        cells_split <- split(cells,  cut(seq_along(cells), 3, labels = FALSE))
        reps[[1]] <- c(reps[[1]], cells_split[1])
        reps[[2]] <- c(reps[[2]], cells_split[2])
        reps[[3]] <- c(reps[[3]], cells_split[3])
      }
      else if (sample_annot_table[celltype, sample] >= 90) {
        cells <- WhichCells(atlas, expression = Annotation ==  celltype & SampleID == sample)
        cells_split <- split(cells,  cut(seq_along(cells), 2, labels = FALSE))
        reps[[1]] <- c(reps[[1]], cells_split[1])
        reps[[2]] <- c(reps[[2]], cells_split[2])
      }
    }
  }
  return(reps)
}

replicates_list <- create_pseudorep(atlas)

for (i in seq_along(replicates_list)) {
  replicate_name <- paste0("rep", i)
  cells <- unlist(replicates_list[[i]])
  atlas$rep[cells] <- replicate_name
}
```

```{r}
bulk <- AggregateExpression(subset(atlas,  rep %in% c('rep1', 'rep2', 'rep3')),
                            return.seurat = T, slot = "counts", assays = "RNA", 
                            group.by = c("Annotation", "SampleID", "less18M", 'rep'))
Idents(bulk) <- "less18M"
sample_sex_map <- data.frame(
  SampleID = atlas$SampleID,
  Sex = atlas$Sex
) %>% unique()

# Add Sex to bulk object by matching SampleID
bulk$Sex <- sample_sex_map$Sex[match(gsub('-', '_', bulk$SampleID), sample_sex_map$SampleID)]

sample_mycn_map <- data.frame(
  SampleID = atlas$SampleID,
  MYCN = atlas$MYCN_status
) %>% unique()
bulk$MYCN_status <- sample_mycn_map$MYCN[match(gsub('-', '_', bulk$SampleID), sample_mycn_map$SampleID)]

sample_method_map <- data.frame(
  SampleID = atlas$SampleID,
  method = atlas$method
) %>% unique()
bulk$method <- sample_method_map$method[match(gsub('-', '_', bulk$SampleID), sample_method_map$SampleID)]

qsave(bulk, paste0(PREPRDATADIR, 'bulk_replicates_ATLAS.qs'))
```

```{r}
bulk <- qread(paste0(PREPRDATADIR, 'bulk_replicates_ATLAS.qs'))
```

## EDA

```{r}
datasets <- c('grossmann', 'patel', 'jansky', 'dong', 'bonine', 'verhoeven', 'wienke')
extract_dataset <- function(sample_id) {
  # Convert known datasets to lowercase for matching
  datasets_lower <- tolower(datasets)
  
  # Convert sample_id to lowercase for matching
  sample_id_lower <- tolower(sample_id)
  
  # Find which dataset appears in the sample_id
  dataset_match <- datasets_lower[sapply(datasets_lower, function(x) grepl(x, sample_id_lower))]
  
  # Return the first match in original case
  if (length(dataset_match) > 0) {
    return(datasets[tolower(datasets) == dataset_match[1]])
  } else {
    return(NA)
  }
}
```

```{r fig.height=4, fig.width=12}
# First normalize the data if not already done
bulk <- NormalizeData(bulk)

# Find variable features
bulk <- FindVariableFeatures(bulk, selection.method = "vst")

# Scale the data
bulk <- ScaleData(bulk)

# Run PCA
bulk <- RunPCA(bulk, features = VariableFeatures(object = bulk))

# Visualize PCA
# Basic PCA plot
PCAPlot(bulk)

# By dataset
bulk$dataset <- sapply(bulk$SampleID, extract_dataset)
DimPlot(bulk, reduction = "pca", group.by = "dataset") + 
    ggtitle("PCA colored by Dataset")

# More customized PCA plots using ggplot2
# By age group
DimPlot(bulk, reduction = "pca", group.by = "less18M", split.by = "dataset") + 
    ggtitle("PCA colored by Age Group")



# By cell type
DimPlot(bulk, reduction = "pca", group.by = "Annotation", split.by = "dataset") + 
    ggtitle("PCA colored by Cell Type")

for (i in )
```

## FIT MODEL

Dong2020 - all
Jansky2021 - sex only
Verhoeven2022 - MYCN only
Wienke2024 - all
Grossman2024 - all
Bonine2024 - MYCN only
Patel2024 - all

```{r}
#TODO: write function to do deg by celltypes 
fit_model <- function(bulk){
  counts <- GetAssayData(bulk, slot = "counts")
  
  # Create base metadata
  metadata <- data.frame(
    group = as.factor(bulk$less18M),
    SampleID = bulk$SampleID,
    rep = as.factor(bulk$rep)  # Always include rep initially
  )
  rownames(metadata) <- colnames(bulk)
  
  # Create design formula parts, checking number of levels
  design_parts <- c()
  
  # Check group levels
  if(length(unique(metadata$group)) < 2) {
    stop("Not enough groups for comparison (need both age groups present)")
  }
  
  # Check rep levels
  if(length(unique(metadata$rep)) > 1) {
    design_parts <- c(design_parts, "rep")
    print("Including rep in design matrix")
  } else {
    print("Only one replicate level, excluding from design")
  }
  
  # Add Sex if available and has multiple levels
  if("Sex" %in% colnames(bulk@meta.data) && !any(is.na(bulk$Sex))) {
    metadata$Sex <- as.factor(bulk$Sex)
    if(length(unique(metadata$Sex)) > 1) {
      design_parts <- c(design_parts, "Sex")
      print("Including Sex in design matrix")
    } else {
      print("Only one Sex level, excluding from design")
    }
  }
  
  # Add MYCN_status if available and has multiple levels
  if("MYCN_status" %in% colnames(bulk@meta.data) && !any(is.na(bulk$MYCN_status))) {
    metadata$MYCN_status <- as.factor(bulk$MYCN_status)
    if(length(unique(metadata$MYCN_status)) > 1) {
      design_parts <- c(design_parts, "MYCN_status")
      print("Including MYCN_status in design matrix")
    } else {
      print("Only one MYCN_status level, excluding from design")
    }
  }
  
  # Print factor levels for debugging
  print("Factor levels in data:")
  for(col in colnames(metadata)) {
    if(is.factor(metadata[[col]])) {
      print(paste(col, "levels:", paste(levels(metadata[[col]]), collapse=", ")))
    }
  }
  
  # Create design formula
  if(length(design_parts) > 0) {
    design_formula <- paste(c("~", paste(design_parts, collapse = " + "), "group"), collapse = " + ")
  } else {
    design_formula <- "~ group"
  }
  print(paste("Design formula:", design_formula))
  
  # Create design matrix
  design <- model.matrix(as.formula(design_formula), data = metadata)
  print(paste("Design formula:", design_formula))
  
  dge <- DGEList(counts = counts,
                 samples = metadata)
  
  # Filter and normalize
  print("Dimensions before subsetting:")
  print(dim(dge))
  keep <- filterByExpr(dge)
  dge <- dge[keep, , keep.lib.sizes=FALSE]
  print("Dimensions after subsetting:")
  print(dim(dge))
  
  dge <- calcNormFactors(dge)
  
  # Estimate dispersion and fit model
  dge <- estimateDisp(dge, design, robust = TRUE)
  fit <- glmQLFit(dge, design, robust = TRUE)
  
  return(list("fit"=fit, "design"=design, "dge"=dge))
}

```

```{r}
# Function to check if we have enough samples in each group
check_sample_size <- function(bulk, min_samples_per_group = 2) {
  group_counts <- table(bulk$less18M)
  enough_samples <- all(group_counts >= min_samples_per_group)
  
  if(!enough_samples) {
    print(paste("Not enough samples in each group. Sample counts:", 
                paste(names(group_counts), group_counts, collapse=", ")))
  }
  return(enough_samples)
}

# Main analysis function
run_deg_analysis <- function(bulk) {
  # Get all valid combinations that exist in the data
  valid_combinations <- table(bulk$Annotation, bulk$dataset)
  print("Available combinations of cell types and datasets:")
  print(valid_combinations)
  
  # Store results
  all_results <- list()
  
  for(celltype in unique(bulk$Annotation)) {
    print(paste("\n=== Processing celltype:", celltype, "==="))
    all_results[[celltype]] <- list()
    
    for(dataset_name in unique(bulk$dataset)) {
      print(paste("\n--- Dataset:", dataset_name, "---"))
      
      # Check if this combination exists
      if(valid_combinations[celltype, dataset_name] == 0) {
        print(paste("No cells found for", celltype, "in dataset", dataset_name, "- skipping"))
        next
      }
      
      # Subset data
      subset_bulk <- subset(bulk, 
                           Annotation == celltype & 
                           dataset == dataset_name)
      
      # Check sample size
      if(ncol(subset_bulk) < 3) {
        print("Too few total samples, skipping")
        next
      }
      
      if(!check_sample_size(subset_bulk)) {
        print("Unbalanced groups, skipping")
        next
      }
      
      # Run DEG analysis
      tryCatch({
        results <- fit_model(subset_bulk)
        
        # Test for DE
        group_coef <- which(colnames(results$design) == "groupTRUE")
        contrast <- rep(0, ncol(results$design))
        contrast[group_coef] <- 1
        qlf <- glmQLFTest(results$fit, contrast = contrast)
        de_results <- topTags(qlf, n = Inf)
        
        # Store results
        all_results[[celltype]][[dataset_name]] <- list(
          de_table = de_results$table,
          fit = results$fit,
          dge = results$dge,
          design = results$design
        )
        
        # Create diagnostic plots
        par(mfrow=c(2,2))
        
        # MDS plot
        plotMDS(results$dge, 
                col = ifelse(results$dge$samples$group == "TRUE", "red", "blue"),
                main = paste("MDS Plot -", dataset_name))
        legend("topright", 
               legend = c(">18m", "<=18m"),
               col = c("red", "blue"),
               pch = 16)
        
        plotBCV(results$dge)
        plotQLDisp(results$fit)
        plotMD(qlf)
        
        # Print summary
        print(paste("Number of genes tested:", nrow(de_results$table)))
        print(paste("Genes with FDR < 0.05:", sum(de_results$table$FDR < 0.05)))
        print(paste("Genes with FDR < 0.1:", sum(de_results$table$FDR < 0.1)))
        
      }, error = function(e) {
        print(paste("Error in analysis:", e$message))
      })
    }
  }
  
  return(all_results)
}
```

```{r fig.height=7, fig.width=7}
# Run the analysis
results <- run_deg_analysis(bulk)
```

```{r}
# Function to summarize results
summarize_results <- function(results) {
  summary_df <- data.frame()
  
  for(celltype in names(results)) {
    for(dataset in names(results[[celltype]])) {
      de_table <- results[[celltype]][[dataset]]$de_table
      
      row <- data.frame(
        Celltype = celltype,
        Dataset = dataset,
        Total_Genes = nrow(de_table),
        DE_genes_FDR05 = sum(de_table$FDR < 0.05),
        DE_genes_FDR10 = sum(de_table$FDR < 0.1),
        Up_regulated = sum(de_table$FDR < 0.05 & de_table$logFC > 0),
        Down_regulated = sum(de_table$FDR < 0.05 & de_table$logFC < 0)
      )
      summary_df <- rbind(summary_df, row)
    }
  }
  
  return(summary_df)
}

# Print summary
summary_table <- summarize_results(results)
print(summary_table)
```

## Combine P-VAL

```{r}
perform_meta_analysis <- function(all_results, celltype) {
  # Get all datasets for this celltype
  datasets <- names(all_results[[celltype]])
  
  if(length(datasets) < 2) {
    print(paste("Not enough datasets for", celltype))
    return(NULL)
  }
  
  # Get common genes across all datasets
  gene_lists <- lapply(datasets, function(dataset) {
    rownames(all_results[[celltype]][[dataset]]$de_table)
  })
  common_genes <- Reduce(intersect, gene_lists)
  
  print(paste("Number of common genes:", length(common_genes)))
  
  # Create matrix to store results
  meta_results <- data.frame(
    gene = common_genes,
    num_datasets = length(datasets),
    consistent_direction = NA,
    combined_p = NA,
    mean_logFC = NA,
    stringsAsFactors = FALSE
  )
  
  # For each gene
  for(gene in common_genes) {
    # Collect logFC and p-values across datasets
    logFCs <- numeric()
    pvalues <- numeric()
    sample_sizes <- numeric()
    
    for(dataset in datasets) {
      res_table <- all_results[[celltype]][[dataset]]$de_table
      logFCs <- c(logFCs, res_table[gene, "logFC"])
      pvalues <- c(pvalues, res_table[gene, "PValue"])
      sample_sizes <- c(sample_sizes, ncol(all_results[[celltype]][[dataset]]$dge$counts))
    }
    
    # Check direction consistency
    is_consistent <- all(logFCs > 0) || all(logFCs < 0)
    
    if(is_consistent) {
      # Calculate weighted mean logFC
      weighted_logFC <- weighted.mean(logFCs, sample_sizes)
      
      # Combine p-values using weighted Z-method
      z_scores <- qnorm(pvalues/2) * sign(logFCs)  # one-sided p-values
      weights <- sqrt(sample_sizes)
      weighted_z <- sum(z_scores * weights) / sqrt(sum(weights^2))
      combined_p <- 2 * pnorm(-abs(weighted_z))  # back to two-sided p-value
      
      # Store results
      meta_results[meta_results$gene == gene, "consistent_direction"] <- TRUE
      meta_results[meta_results$gene == gene, "combined_p"] <- combined_p
      meta_results[meta_results$gene == gene, "mean_logFC"] <- weighted_logFC
    } else {
      meta_results[meta_results$gene == gene, "consistent_direction"] <- FALSE
    }
  }
  
  # Add FDR
  meta_results$FDR <- p.adjust(meta_results$combined_p, method = "BH")
  
  # Filter for consistent direction and sort by FDR
  final_results <- meta_results[meta_results$consistent_direction, ]
  final_results <- final_results[order(final_results$FDR), ]
  
  # Print summary
  print("Meta-analysis summary:")
  print(paste("Total genes analyzed:", nrow(meta_results)))
  print(paste("Genes with consistent direction:", sum(meta_results$consistent_direction, na.rm=TRUE)))
  print(paste("Significant genes (FDR < 0.05):", sum(final_results$FDR < 0.05, na.rm=TRUE)))
  print(paste("Significant genes (FDR < 0.1):", sum(final_results$FDR < 0.1, na.rm=TRUE)))
  
  return(final_results)
}
```

```{r}
# Run meta-analysis for each cell type
meta_analysis_results <- list()
for(celltype in names(results)) {
  print(paste("\nPerforming meta-analysis for", celltype))
  meta_analysis_results[[celltype]] <- perform_meta_analysis(results, celltype)
}

# Function to create summary visualization
plot_meta_results <- function(meta_results, celltype) {
  if(is.null(meta_results)) return(NULL)
  
  significant_genes <- meta_results[meta_results$FDR < 0.05, ]
  
  # Volcano plot
  ggplot(meta_results, aes(x = mean_logFC, y = -log10(FDR))) +
    geom_point(aes(color = FDR < 0.05)) +
    theme_minimal() +
    ggtitle(paste("Meta-analysis results for", celltype)) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
    geom_vline(xintercept = 0, linetype = "dashed")
}

# Create plots for each cell type
for(celltype in names(meta_analysis_results)) {
  print(plot_meta_results(meta_analysis_results[[celltype]], celltype))
}
```

## Heatmaps

```{r}
create_patient_heatmap <- function(bulk, celltype, meta_results, top_n = 50) {
  # Subset bulk object for the celltype
  bulk_subset <- subset(bulk, Annotation == celltype)
  
  # Get normalized counts
  counts <- GetAssayData(bulk_subset, slot = "data")  # normalized data
  
  # Get top DE genes from meta-analysis
  if(!is.null(meta_results[[celltype]])) {
    top_genes <- meta_results[[celltype]]$gene[1:min(top_n, nrow(meta_results[[celltype]]))]
  } else {
    return(NULL)
  }
  
  # Subset counts matrix for top genes
  expr_matrix <- counts[top_genes, ]
  
  # Get patient metadata
  metadata <- data.frame(
    Age_group = bulk_subset$less18M,
    Dataset = bulk_subset$dataset,
    row.names = colnames(bulk_subset)
  )
  
  # Create annotation colors
  ann_colors <- list(
    Age_group = c("TRUE" = "red", "FALSE" = "blue"),
    Dataset = rainbow(length(unique(metadata$Dataset)))
  )
  names(ann_colors$Dataset) <- unique(metadata$Dataset)
  
  # Create heatmap
  pheatmap(expr_matrix,
           annotation_col = metadata,
           annotation_colors = ann_colors,
           main = paste("Top", top_n, "DE genes in", celltype),
           show_colnames = FALSE,
           cluster_rows = TRUE,
           cluster_cols = TRUE,
           scale = "row",
           fontsize_row = 8)
}

# Create heatmaps for each cell type
for(celltype in names(meta_analysis_results)) {
  print(paste("Creating patient heatmap for", celltype))
  create_patient_heatmap(bulk, celltype, meta_analysis_results)
}
```

### Dataset-based

```{r}
create_patient_heatmaps <- function(bulk, meta_results, top_n = 50, min_group_size = 3) {
  library(pheatmap)
  
  for(celltype in unique(bulk$Annotation)) {
    print(paste("\nProcessing", celltype))
    
    # Get valid datasets for this cell type
    valid_combos <- table(bulk$Annotation, bulk$dataset)
    valid_datasets <- names(valid_combos[celltype,valid_combos[celltype,] > 0])
    
    for(dataset_name in valid_datasets) {
      print(paste("\nChecking", dataset_name))
      
      # Subset data
      subset_data <- subset(x = bulk, 
                           subset = Annotation == celltype & dataset == dataset_name)
      
      # Get sample counts
      sample_counts <- table(subset_data$less18M)
      print(paste(dataset_name, "sample counts:", 
                 paste(names(sample_counts), sample_counts, collapse=", ")))
      
      # Check sample sizes
      if(length(sample_counts) < 2 || any(sample_counts < min_group_size)) {
        print("Insufficient samples - skipping")
        next
      }
      
      # Get expression data
      expr_matrix <- as.matrix(GetAssayData(subset_data, slot = "data"))
      
      # Get genes
      if(!is.null(meta_results[[celltype]])) {
        top_genes <- head(meta_results[[celltype]]$gene, top_n)
        common_genes <- intersect(top_genes, rownames(expr_matrix))
        
        if(length(common_genes) > 0) {
          # Subset expression matrix
          expr_matrix <- expr_matrix[common_genes, , drop = FALSE]
          
          # Create annotation
          anno_col <- data.frame(
            Age_group = factor(subset_data$less18M),
            row.names = colnames(expr_matrix)
          )
          
          # Create title
          title <- paste0(celltype, " - ", dataset_name, "\n",
                         "Total n=", ncol(subset_data), " (",
                         "<=18m: n=", sample_counts["FALSE"], ", ",
                         ">18m: n=", sample_counts["TRUE"], ")")
          
          # Display heatmap
          print(pheatmap(expr_matrix,
                        annotation_col = anno_col,
                        annotation_colors = list(Age_group = c("TRUE" = "red", "FALSE" = "blue")),
                        main = title,
                        show_colnames = FALSE,
                        cluster_rows = TRUE,
                        cluster_cols = TRUE,
                        scale = "row",
                        fontsize_row = 8))
          
        } else {
          print("No common genes found")
        }
      } else {
        print("No meta-analysis results available")
      }
    }
  }
}

# Run with minimum 3 samples per group
create_patient_heatmaps(bulk, meta_analysis_results, min_group_size = 3)
```

## Forest plots

```{r}
# Function for forest plot
create_forest_plot <- function(all_results, celltype, gene) {
  library(ggplot2)
  library(metafor)
  
  # Collect results for this gene across datasets
  datasets <- names(all_results[[celltype]])
  logFC <- numeric()
  se <- numeric()
  dataset_names <- character()
  
  for(dataset in datasets) {
    res_table <- all_results[[celltype]][[dataset]]$de_table
    if(gene %in% rownames(res_table)) {
      logFC <- c(logFC, res_table[gene, "logFC"])
      # Calculate SE from p-value and logFC
      z_score <- qnorm(res_table[gene, "PValue"]/2, lower.tail = FALSE)
      se <- c(se, abs(res_table[gene, "logFC"]/z_score))
      dataset_names <- c(dataset_names, dataset)
    }
  }
  
  # Create data frame
  forest_data <- data.frame(
    dataset = dataset_names,
    logFC = logFC,
    se = se,
    stringsAsFactors = FALSE
  )
  
  # Perform random-effects meta-analysis
  meta_res <- rma(yi = logFC, sei = se, data = forest_data)
  
  # Create forest plot
  forest_plot <- ggplot(forest_data, aes(y = dataset)) +
    geom_point(aes(x = logFC), size = 3) +
    geom_errorbarh(aes(xmin = logFC - 1.96*se, 
                      xmax = logFC + 1.96*se), 
                   height = 0.2) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = meta_res$b[1], color = "red", linetype = "dashed") +
    theme_minimal() +
    labs(title = paste("Forest plot for", gene, "in", celltype),
         x = "Log Fold Change",
         y = "Dataset")
  
  return(forest_plot)
}
```

```{r}
# Create forest plots for top genes
for(celltype in names(meta_analysis_results)) {
  if(!is.null(meta_analysis_results[[celltype]])) {
    # Get top 5 genes
    top_genes <- meta_analysis_results[[celltype]]$gene[1:min(5, nrow(meta_analysis_results[[celltype]]))]
    
    for(gene in top_genes) {
      print(create_forest_plot(results, celltype, gene))
    }
  }
}
```

```{r}
create_forest_plot_custom <- function(all_results, celltype, gene_of_interest) {
  
  # Collect results for this gene across datasets
  forest_data <- data.frame()
  
  for(dataset in names(all_results[[celltype]])) {
    res_table <- all_results[[celltype]][[dataset]]$de_table
    
    if(gene_of_interest %in% rownames(res_table)) {
      # Get logFC and p-value
      logFC <- res_table[gene_of_interest, "logFC"]
      pvalue <- res_table[gene_of_interest, "PValue"]
      
      # Calculate standard error from p-value and logFC
      # Using the relationship between z-score and p-value
      z_score <- qnorm(pvalue/2, lower.tail = FALSE)
      se <- abs(logFC/z_score)
      
      # Get sample sizes for the dataset
      n_samples <- ncol(all_results[[celltype]][[dataset]]$dge$counts)
      
      # Add to data frame
      forest_data <- rbind(forest_data, 
                          data.frame(dataset = dataset,
                                   logFC = logFC,
                                   se = se,
                                   pvalue = pvalue,
                                   n = n_samples,
                                   stringsAsFactors = FALSE))
    }
  }
  
  if(nrow(forest_data) == 0) {
    print(paste("Gene", gene_of_interest, "not found in any dataset"))
    return(NULL)
  }
  
  # Perform random-effects meta-analysis
  meta_res <- rma(yi = logFC, sei = se, data = forest_data)
  
  # Add summary effect
  forest_data$dataset <- factor(forest_data$dataset, 
                              levels = forest_data$dataset[order(forest_data$logFC)])
  
  # Create forest plot
  p <- ggplot(forest_data, aes(y = dataset)) +
    # Individual study effects
    geom_point(aes(x = logFC, size = 1/se^2)) +
    geom_errorbarh(aes(xmin = logFC - 1.96*se, 
                      xmax = logFC + 1.96*se), 
                   height = 0.2) +
    # Reference line at zero
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
    # Summary effect
    geom_vline(xintercept = meta_res$b[1], color = "red", linetype = "dashed") +
    # Labels and theme
    theme_minimal() +
    theme(legend.position = "none") +
    labs(title = paste("Forest plot for", gene_of_interest, "in", celltype),
         subtitle = paste("Summary effect:", round(meta_res$b[1], 3), 
                        "(95% CI:", round(meta_res$ci.lb, 3), "to", 
                        round(meta_res$ci.ub, 3), ")"),
         x = "Log Fold Change",
         y = "Dataset") +
    # Add annotations
    annotate("text", x = max(forest_data$logFC + forest_data$se) * 1.2,
             y = forest_data$dataset,
             label = sprintf("p = %.2e", forest_data$pvalue),
             hjust = 0,
             size = 3)
  
  return(list(plot = p, meta_results = meta_res, data = forest_data))
}


f1 <- create_forest_plot_custom(results, "Neuroendocrine", "S100a8")
print(f1$plot)

# For multiple genes of interest
genes_of_interest <- c("S100a8", "S100a9")
forest_plots <- lapply(genes_of_interest, function(gene) {
  create_forest_plot(results, "Neuroendocrine", gene)
})
```

# MAST
## TODO